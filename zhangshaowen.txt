一  高质量高发

1 奔溃:  
java 与 native奔溃的获取

bugly 捕获 java与native （breakpad）奔溃

bugly 相信你能抓到java nativie的anr的log

ANR异常怎么搞:  

监听anr文件
监控消息队列运行时间
anr原理
（这里会迁出一个面出来, 组件的回调函数背系统规定了，组件的回调是谁来调用，跨进程，调用进程是谁, 其实也就是activity启动流程）
http://gityuan.com/2015/10/31/binder-prepare/

anr 检测开源方案: BlockCanary, ANR-WatchDog, SafeLooper 

2 内存

内存泄漏与内存抖动

bitmapt的 像素数据
重复的bitmap 与 不匹配view的图片，超宽率
内存监控模块: 大对象的分配

3  卡顿：
本地工具: systrace, traceview
可以看到所有线程函数调用栈以及各个函数的调用时间，时间占比

facebook 的 profilo 性能统计工具

打点插桩，修改字节码，aspect 性能统计工具，



1 anr 原理，从源码的角度分析，在上面情况下弹出的， (#####未实践##### )
2 anr 采集，如何分析
3 预防

线程被CPU执行
Thread.sleep() 或者线程正在进行文件io操作读取操作，让出cpu，读取完毕进入调度序列

消息： 依赖c函数： natviePollOnce , nativeWake
消息


启动优化：
业务并行，任务依赖 (#####未实践##### )

任务并行：注意锁的问题

4,(上) 启动优化，预览闪屏
   业务初始化并行，阿里的alpha
    ASM 插装,统计函数耗时
（下）启动过程不建议网络IO（负载过高，io性能下降）	
liunx 读文件的时候，以block为单位读取，大小为4kb
	

5, IO 优化
虚拟文件系统 (接口)--->具体的文件系统（实现）
1 为什么磁盘会损坏(可能硬件与软件的问题)
2 为什么io有时候变慢(内存不足，系统回收，把cache清掉了，page cache 丢失)

app 文件系统(page cache:内存缓存(文件的数据))  磁盘(file)
android有两个class
MemoryFile  MappedByteBuffer 内存映射

android binder mmap 一次数据copy (#####未实践##### )
文中提到“我们使用 mmap 仅仅只需要一次数据拷贝”，这个说法是不准确的，内存映射的场景直接操作的就是映射到的内存，不需要额外的一次拷贝。

Binder的方案确实需要一次数据拷贝，那是Binder的机制决定的，而不是因为内存映射需要一次数据拷贝。(#####未实践验证##### )
在Binder机制中，内存映射在一次通信过程中是单侧的：数据发送方通过transact将数据写入到内核态，这个过程需要一次数据拷贝
(写入过程非内存映射，否则不需要“写”)；而接收方直接映射到了这一块内存，接收的过程不需要内存拷贝，所以Binder机制需要一次数据拷贝。

文件读写分离未测试(#####未实践##### )
30个40M大小的文件,分别1，5， 10， 30个线程来读取耗时情况测试(#####未实践##### )
结论CPU ，多线程在I/0操作上并没有那么大, 不是说线程越多，耗时越少，找到平衡点
磁盘io的瓶颈在磁盘带宽
nio例子--->  okhttp okio

大量的小文件合并成大文件，访问的时候通过文件的偏移量与大小来访问，开源项目淘宝的TFS(#####未实践##### )
/libcore/luni/src/main/java/libcore/io/
H A D	IoBridge.java	

1 几百kb的文件不要在主线程做read ----> 低端机很容易anr了
2 读文件的buffer设置为block的整数倍4k
3 资源别泄漏(file.close(), cursor.close())，再也回收不了oom的问题

6 存储优化
存储： 分区，存储空间分区域，单独格式化，单独的文件系统

sp contentProvider file DB

SP: 异步加载文件带锁了，如果没哟加载完成，主线程要去访问，得wait()  --> 所以得出结论预加载sp，如果不看源码，你咋知道，
所以，确实我以前的学习方式有问题啊，没有看源码，听得多，动其实我也动了，源码与文档是最好的老师，当然前提你是能看的动
源码的, 看blog，还去记，脑袋有问题呢，还强行记忆，你能记多久，啊，又是重来，是不是哪里出问题了，确实出问题

SP小文件 ----> 微信使用MMKV 替换了sp, github上的wiki还需要查看(#####未实践#####)
为何SP 跨进程不安全(#####未实践#####)

https://github.com/Tencent/MMKV/wiki/android_ipc
SharedPreference 跨进程不安全





content Provider:(跨进程数据共享(mmap ))

初始化时机为何在Application.onCreate()之前(#####未实践#####)
跨进程访问(binder机制:fd)
binder传输大小限制：1M(#####未实践#####)
进程锁: pthread_mutex

/dev/binder  字符设备文件, 多个进程通过这个文件通信(文件锁)


没有实践就没有发言权
作为程序员，我们应该追求完美，最后钱自然而然的来了，所以千万别说因为钱
源码在手，天下我有


对象序列话: Seriable(反射读取value，性能低) 与 parceable (性能更高)， seriva框架twtter

数据序列化： json,xml,protobuf(二进制压缩)


DB 

多进程并发与多线程并发
sqlite里面做号了同步，锁的粒度是文件(粒度太大了，能不能做到表锁甚至行锁)
数据库常见异常DatabaseLockedExeception, 多线程或者多进程导致，可以捕获这个异常，延时操作

查询优化: 索引表---> 原始表

WCDB 微信的开源的数据库 (#####未实践#####)
orm框架,greenDAO  Room (面向的是开发者使用方便: 底层还是sqlite)

并发的两个维度: 进程并发，一个进程中的多个线程并发
sqlite 默认支持多进程并发, 使用的是文件锁(锁的力度够大了)
也模式支持多线程并发，所以应用程序不需要并发安全的问题，只不过还是文件锁，整个DB的锁，没有细分到库，到表，到行锁的力度
可以同时读
写是互斥的

数据加密(AES,DES)

7 网络优化:

手机双网卡: wifi , 移动网络
LinkTurbo: 加速： 使用wifi的同时使用移动网络加速   

何为网络优化，优化什么：
 工具(fiddler,wireshark, charles),注意，https，安装号嗅探工具的证书到客户端一定是可以抓到https的包
 一 延迟：数据包从源地址发出，到目的地，以及回来的时间
 二 带宽：
 三 安全(https: 已经为数据加过密(三方工具可以抓到)，  二次加密(AES,DES),自己认为重要的数据)
 四 压缩GZIP：数据量小，成功率就会高，发送的请求包含(url(参数), header, body),针对这三个来做事情,也就是协议的问题(json与protobuf)
 五 图片(压缩，webp) 
 
 https: 连接后密钥协商 与 蓝牙连接之后特征值确定一样
 网络请求= 发起请求 + DNS解析(本地缓存, LOcalDNS劫持, DNS调度问题) + 建立连接(三次握手,密钥协商,连接复用(活着)与长连接(keep-alive)) +  发送数据包 + 接收数据包(IO处理，解密) + 关闭连接(三次，麻烦)  
 
连接复用: 在连接上发送请求，客户端多个请求同时使用同一个连接发送，服务的从这个连接获取多个请求处理
 
 LocalDNS劫持 ---> http DNS (腾讯云，阿里云)，获取一批IP列表轮询
 
 合格的开发者知道怎么做，优秀的开发者知道为什么这样做

网络库
square okhttp   chrominu cronet   微信 mars    

网络监控(一次往返的时间，从发起请求到收到响应，其实在volley已经做过了)
性能监控，aspect(编译插桩,最好的实现方案 360 APM未实践ArgusAPM #####未实践#####)

网络日志与远程诊断(#####未实践#####)


8 UI 优化

适配(dp, 限定符资源)
匿名共享内存(#####未实践#####)
overDraw  	



 高效开发
 程序员最痛恨写文档，还有别人不写文档
 9 编译: 三方开源的编译工具 facebook的Buck 与 google 的 bazel
 
 install run (增量编译)      
 
 10  编译插桩(AspectJ, ASM, ReDex)
 性能监控，网络监控，耗电监控
 
 java 文件的生成 (APT)
 
 字节码的修改(生成class字节码之后)

 
 监控三方SDK某个接口的性能(#####未实践#####)
 
 某个函数的性能有两种实现，一种是在调用端，一种是函数内部，两个问题： 调用点可能是有很多，第二 没有函数源码
 
插桩就是修改代码，例如，奔溃加try catch
无痕埋点: pageid, 控件 resource id(不会变有疑问)， 自动画埋点只能有简单数据，还需要自己设计一套DSL语言,能让插装代码通过反射获取到，这周验证（未验证）

DSL语言： test.a 表示实例test, 字段a  test.test()  表示实例test,调用test方法, [] 数组
插桩方法

java 文件 :  android annotation 自动生成java文件

字节码： 修改字节码(代码监控，代码修改，代码分析)  

操作字节码实现编译插桩功能：
  
AspectJ: 可以作用在方法被调用的位置，方法体，静态代码快，异常处理前后插入自定义的代码

简书大牛
https://www.jianshu.com/u/35083fcb7747

高可用上报组件：

数据往哪里写:  内存， mmap,  file 这三种方式需要做对比，对比两个维度， 根据数据量大小和写完时间的对比，在I/O优化中有 (未实践)

采样，存储，上报，容灾

代码埋点:xxx
可视化埋点  Mixpanel
无痕埋点: GrowingIO
   
鹏飞的学习心得   
c/c++ 环境编程参考文档   
https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5

焦虑不是迷茫与恐慌，而是认识到自己的不足，然后加足马力补齐短板

源码实现自己看，除非遇到某一个知识点跳不过去，采取搜答案，然后再验证

三方library，自己模拟实现
全栈发展：


frameworks/base/services/core/java/com/android/server/am/ActiveServices.java

ActivityThread.main(){
 Looper.prepareMainLooper();
 xxxxxx

Looper.loop();
}
->准备好了一个looper{ MQ   }

sThreadLocal.set(new Looper(quitAllowed));
Looper 与 threadlocal(Thread.currentThread()获取) 关联



(frameworks/base/core/jni/android_os_MessageQueue.cpp)：
/system/core/libutils/include/utils/Looper.h

 obj.wait();  --> 调用到了 nativeWait();


uint64_t inc = 1;
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));

int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);







frameworks/base/services/core/java/com/android/server/am/
  - ActivityManagerService.java
  - ActiveServices.java
  - ServiceRecord.java
  - ProcessRecord.java

frameworks/base/core/java/android/app/
  - IActivityManager.java
  - ActivityManagerNative.java (内含AMP)
  - ActivityManager.java
  
  - IApplicationThread.java
  - ApplicationThreadNative.java (内含ATP)
  - ActivityThread.java (内含ApplicationThread)
  
  - ContextImpl.java
