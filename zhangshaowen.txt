一  高质量高发(学完就立马动手)

1 奔溃:  
java 与 native奔溃的获取, 目的是获取堆栈信息

bugly 捕获 java与native （breakpad）c/c++奔溃, 已测试ok

bugly 相信你能抓到java nativie的anr的log

OOM问题怎么搞，uncatchException能catch住吗?Thread.setDefaultExceptionHandler()能catch住，这个时候app还能干其他事情吗?如果做其他事情会不会二次奔溃  

java 异常Thread.setDefaultExceptionHandler(）获取，注意你是覆盖了系统的默认实现，这时候你得注意覆盖是否有问题，是否需要保存系统得默认实现

c/c++ 异常： 发出异常信号sig, linux 发出异常信号，signal (int ,sigAction), 但是同样注意系统得默认实现,但是只是只是获取到了这么一个异常信号，堆栈信息这么来，
            google breakpad 能获取到地址， 然后ndk底下有一个哦工具 address2Line(),能打印除行号


ANR异常怎么搞:  
如何获取anr信息: 思路: 参考 trace.txt 系统是如何生存的, 系统是通过这个类ProcessCpuTracker.java获取，其实就是读取linux 中 /proc/xxxx 虚拟文件(size=0)

各个组件以及input 输入ANR 逻辑 (未debug)

监听anr文件, 再无权限，需要了解得是系统如何生成trace.txt文件

监控消息队列运行时间, 

anr原理
（这里会迁出一个面出来, 组件的回调函数被系统规定了，组件的回调是谁来调用，跨进程，调用进程是谁, 其实也就是activity启动流程）
http://gityuan.com/2015/10/31/binder-prepare/

anr检测开源方案: BlockCanary, ANR-WatchDog, SafeLooper 





2 内存 （设备分级(设备的内存,cpu核心数，帧率)， Bitmap, 内存泄漏, 安装包大小  ）

帧率： 如何获取帧率，简单一点，一秒钟有多少帧 （系统接口 Choreographer.postFrameCallback(long startdTimePerFrame)）返回每一帧绘制的开始时间
      异常帧率模拟




matrix 有HPROF文件裁剪与重复图片监控的实现 （未实践）
APK Checker: 针对 APK 安装包的分析检测工具，根据一系列设定好的规则，检测 APK 是否存在特定的问题，并输出较为详细的检测结果报告，用于分析排查问题以及版本追踪
Resource Canary: 基于 WeakReference 的特性和 Square Haha 库开发的 Activity 泄漏和 Bitmap 重复创建检测工具
Trace Canary: 监控ANR、界面流畅性、启动耗时、页面切换耗时、慢函数及卡顿等问题
SQLite Lint: 按官方最佳实践自动化检测 SQLite 语句的使用质量
IO Canary: 检测文件 IO 问题，包括：文件 IO 监控和 Closeable Leak 监控
Battery Canary: 监控 App 活跃线程（待机状态 & 前台 Loop 监控）、ASM 调用 (WakeLock/Alarm/Gps/Wifi/Bluetooth 等传感器)、 
后台流量 (Wifi/移动网络)等 Battery Historian 统计 App 耗电的数据



内存优化的常见思路 (数据结构ArrayMap),体积更加小的序列话方法（protobuf）, view 复用，对象池 (Message)

堆内存不足(GC ---> OOM)  物理内存不足(low memory kill(依照进程的优先级)  ---->  重启)   虚拟地址不足 (oom, 内存分配失败, kill )

内存监控：
采集方式: 因为没有回调，那只能轮训，app在前台, 5分之一次,统计内存使用率，pss，java端大小，触顶率
GC 监控

运行内存与安装包体积优化

内存泄漏与内存抖动

内存泄漏：永久泄漏还是短时间泄漏（体现在网络访问的时候）

bitmapt的 像素数据:  android系统版本像素数据存放的区域不一样  version<3.0 像素数据存在native中，充分利用好物理内存，提高内存的使用率，注意什么时候回收，依赖finalize函数调用回收,
3.0>version<7.0  像素数据在堆上(像素数据随着对象的回收而回收，当然带来的问题是gc)，因为图片的像素占住空间很大，很容易oom，这时候物理内存可能还有很大空间，但是没有用上，系统内存没有完全利用起来， 所以8.0之后又放到了nativie中，为了提升内存的使用率，NativieAllocationRegistry这个class

重复的bitmap 与 不匹配view的图片，超宽率
内存监控模块: 大对象的分配 (c)

Zygote 进程启动加载framework.jar与主题, 每个进程都是从zygote进程 fork出来的(内存copy)
fork进程的含义:
1 创建了新的子进程，谁创建它的就是父进程(两个都有独立的空间)
2 复制了父进程的内存空间，在fork这一个时间点，父子进程的内容是一样的

clone():  类似fork,  但父进程更加精细控制， 是否虚拟地址共享，是否fd共享
两个问题:  android 项目里面另开进程，父亲大人是谁: 是zygote64进程  ps -A 查看pid 与ppid 解决了
第二个是: 两个进程证明一下，到底是谁 , 都是 zygote64进程

可以作为JC ROOT 对象:
1 类静态属性： 静态的引用（方法区）
2 常量引用的对象 常量的引用(方法区)
3 JNI 引用的对象 (java 给c 传递的对象)
4 虚拟机栈 (栈帧中的本地变量表，其实就是局部变量，引用类型) 中引用的对象 callback，

java虚拟机作用: 帮助java对象申请内存，回收内存(那咋回收，一定是某种算法) (未实践)

java 虚拟机内存运行时的各个区域(为什么要分区域: 变量创建与销毁的时间不一样， 还有一些是随着用户线程启动和结束而建立与销毁)

1  程序计数器(每个线程都有一个哦哦，独立存储,线程私有，这是正常的呀): 存啥？？？
   当前线程的行号---> 取指令执行
   
2 java虚拟机栈  （也是线程私有，每个线程都有一个，声明周期与线程一致）存啥？？？？  存栈帧, 一个方法一个栈帧
  
  存放java方法对应的栈帧，一个方法对应一个栈帧，方法完栈帧完，好，栈帧存啥: 方法里面有啥， 局部变量，多个局部变量就是一个表了，存放对象的引用，注意
  不是对象，对象实在堆中哦， (这块会出现stackoverflow)
  
  3 本地方法栈 (指的是c函数)
  
  4  堆 
  java对象实例与数组 就这这里，也只存放对象与数组，特点，内存大，所有线程共享，所以就会有同步问题
  同时这里有对象池优化，有内存抖动的问题，函数被调用多次的时候，如果在这里 new obj 或者数组，考虑缓存
  GC 就是管理这个区域， 为何 full gc 会 stop the world， 因为堆内存共享，不暂停会有问题，我回收了一个对象
  另外的线程还在用，出问题了，好，接下来就是回收算法，有很多，采用分代回收
  
  堆空间两块区域: 新生代 和 老年代
  
  这块区域跑出OOM异常
  
  5 方法区 （存啥）
  所有线程共享， 存放Class字节码（有啥? 字段，方法，接口描述）， 常量池，静态变量，代码(编译后的哦)
  
  接口回调如何防止内存泄漏 ？？？？(未实践)
  
可以作为 gc root 的节点
app 中  静态引用，常量引用，栈帧的本地变量(以接口回调实例)
系统的一些东西，比如 输入法....

gc要回收对象是不是能回收，它要去分析某个时间点堆上的快照，如果堆上的对象还在变化
那没有意义，所以gc时候，会暂停其他所有线程(stop the world)，卡顿从这里开始，

堆内存分配与回收(java中都是自动的,c++/c不是哦)

堆(还有一个线程私有区域Thread local)  划分{新生代，老年代 } 根据对象存活时间(age)
minor gc 速度快, 针对的是 新生代区域
full gc  速度慢，是minor gc 十倍的时间,  针对的是老年代区域

经过15次minorgc 后 对象如果没有死，从新生代copy 到老年代
HandlerThread (本质是Thread, 多了一个looper属性,就是有一个死循环的线程)
IntentService （本质是service，多了一个looper属性,就是有一个死循环的线程）

gc 会导致 stop the world，暂停应用所有线程，必须是在某一个时间点上分析内存，引用链关系，也相当于应用程序冻结在了某一个时间点
等待GC工作完成，不可以出现在分析过程中，引用关系还在不断的变化，那分析结果的准确性无法保证，GC 回收无用对象，他需要进行可达性分析工作


3  卡顿：(卡顿过程中函数耗时时间---->插桩 或 profilo 方案)
本地工具: systrace, traceview，这个只是本地做的
可以看到所有线程函数调用栈以及各个函数的调用时间，时间占比

facebook 的 profilo 性能统计工具

打点插桩，修改字节码，aspect 性能统计工具，给自己关心的每个函数编译时插桩,也就是给函数的入口(起始时间)与出口(结束时间)
关键线程的函数调用

查看进程cpu的使用率
cat /proc/{pid}/stat

查看系统的cpu使用率
cat /proc/stat

top 

synchronized (this) { //BLOCKED 等待获取对象锁，在这里有可能会被卡住，因为这个时候对象锁可能会被其他线程占用，会被 BLOCKED
     this.wait();     // 进入waiting 状态，释放CPU资源，也释放锁，要想醒过来，需要需要其来唤醒
}




1 anr 原理，从源码的角度分析，在上面情况下弹出的， (#####未实践##### )
2 anr 采集，如何分析
主流方案：
BlockCanary  (#####未实践##### )
Anr-WatchDog    (#####未实践##### )
SafeLooper:

matrix 必杀技  (#####未实践##### )


3 预防

线程被CPU执行
Thread.sleep() 或者线程正在进行文件io操作读取操作，让出cpu，读取完毕进入调度序列

消息： 依赖c函数： natviePollOnce , nativeWake
消息


启动优化：
业务并行，任务依赖 (#####未实践##### )

任务并行：注意锁的问题

4,(上) 启动优化，预览闪屏
   业务初始化并行，阿里的alpha
    ASM 插装,统计函数耗时
（下）启动过程不建议网络IO（负载过高，io性能下降）	
liunx 读文件的时候，以block为单位读取，大小为4kb
	

5, IO 优化
虚拟文件系统 (接口)--->具体的文件系统（实现）
1 为什么磁盘会损坏(可能硬件与软件的问题)
2 为什么io有时候变慢(内存不足，系统回收，把cache清掉了，page cache 丢失)

app 文件系统(page cache:内存缓存(文件的数据))  磁盘(file)
android有两个class
MemoryFile  MappedByteBuffer 内存映射

android binder mmap 一次数据copy (#####未实践##### )
文中提到“我们使用 mmap 仅仅只需要一次数据拷贝”，这个说法是不准确的，内存映射的场景直接操作的就是映射到的内存，不需要额外的一次拷贝。

Binder的方案确实需要一次数据拷贝，那是Binder的机制决定的，而不是因为内存映射需要一次数据拷贝。(#####未实践验证##### )
在Binder机制中，内存映射在一次通信过程中是单侧的：数据发送方通过transact将数据写入到内核态，这个过程需要一次数据拷贝
(写入过程非内存映射，否则不需要“写”)；而接收方直接映射到了这一块内存，接收的过程不需要内存拷贝，所以Binder机制需要一次数据拷贝。

文件读写分离未测试(#####未实践##### )
30个40M大小的文件,分别1，5， 10， 30个线程来读取耗时情况测试(#####未实践##### )
结论CPU ，多线程在I/0操作上并没有那么大, 不是说线程越多，耗时越少，找到平衡点
磁盘io的瓶颈在磁盘带宽
nio例子--->  okhttp okio

大量的小文件合并成大文件，访问的时候通过文件的偏移量与大小来访问，开源项目淘宝的TFS(#####未实践##### )
/libcore/luni/src/main/java/libcore/io/
H A D	IoBridge.java	

1 几百kb的文件不要在主线程做read ----> 低端机很容易anr了
2 读文件的buffer设置为block的整数倍4k
3 资源别泄漏(file.close(), cursor.close())，再也回收不了oom的问题

6 存储优化
存储： 分区，存储空间分区域，单独格式化，单独的文件系统

sp contentProvider file DB

SP: 异步加载文件带锁了，如果没哟加载完成，主线程要去访问，得wait()  --> 所以得出结论预加载sp，如果不看源码，你咋知道，
所以，确实我以前的学习方式有问题啊，没有看源码，听得多，动其实我也动了，源码与文档是最好的老师，当然前提你是能看的动
源码的, 看blog，还去记，脑袋有问题呢，还强行记忆，你能记多久，啊，又是重来，是不是哪里出问题了，确实出问题

SP小文件 ----> 微信使用MMKV 替换了sp, github上的wiki还需要查看(#####未实践#####)
为何SP 跨进程不安全(#####未实践#####)

https://github.com/Tencent/MMKV/wiki/android_ipc
SharedPreference 跨进程不安全





content Provider:(跨进程数据共享(mmap ))

初始化时机为何在Application.onCreate()之前(#####未实践#####)
跨进程访问(binder机制:fd)
binder传输大小限制：1M(#####未实践#####)
进程锁: pthread_mutex

/dev/binder  字符设备文件, 多个进程通过这个文件通信(文件锁)


没有实践就没有发言权
作为程序员，我们应该追求完美，最后钱自然而然的来了，所以千万别说因为钱
源码在手，天下我有


对象序列话: Seriable(反射读取value，性能低) 与 parceable (性能更高)， seriva框架twtter

数据序列化： json,xml,protobuf(二进制压缩)


DB 

多进程并发与多线程并发
sqlite里面做号了同步，锁的粒度是文件(粒度太大了，能不能做到表锁甚至行锁)
数据库常见异常DatabaseLockedExeception, 多线程或者多进程导致，可以捕获这个异常，延时操作

查询优化: 索引表---> 原始表

WCDB 微信的开源的数据库 (#####未实践#####)
orm框架,greenDAO  Room (面向的是开发者使用方便: 底层还是sqlite)

并发的两个维度: 进程并发，一个进程中的多个线程并发
sqlite 默认支持多进程并发, 使用的是文件锁(锁的力度够大了)
也模式支持多线程并发，所以应用程序不需要并发安全的问题，只不过还是文件锁，整个DB的锁，没有细分到库，到表，到行锁的力度
可以同时读
写是互斥的

数据加密(AES,DES)

7 网络优化:

手机双网卡: wifi , 移动网络
LinkTurbo: 加速： 使用wifi的同时使用移动网络加速   

何为网络优化，优化什么：
 工具(fiddler,wireshark, charles),注意，https，安装号嗅探工具的证书到客户端一定是可以抓到https的包
 一 延迟：数据包从源地址发出，到目的地，以及回来的时间
 二 带宽：
 三 安全(https: 已经为数据加过密(三方工具可以抓到)，  二次加密(AES,DES),自己认为重要的数据)
 四 压缩GZIP：数据量小，成功率就会高，发送的请求包含(url(参数), header, body),针对这三个来做事情,也就是协议的问题(json与protobuf)
 五 图片(压缩，webp) 
 
 https: 连接后密钥协商 与 蓝牙连接之后特征值确定一样
 网络请求= 发起请求 + DNS解析(本地缓存, LOcalDNS劫持, DNS调度问题) + 建立连接(三次握手,密钥协商,连接复用(活着)与长连接(keep-alive)) +  发送数据包 + 接收数据包(IO处理，解密) + 关闭连接(三次，麻烦)  
 
连接复用: 在连接上发送请求，客户端多个请求同时使用同一个连接发送，服务的从这个连接获取多个请求处理
 
 LocalDNS劫持 ---> http DNS (腾讯云，阿里云)，获取一批IP列表轮询
 
 合格的开发者知道怎么做，优秀的开发者知道为什么这样做

网络库
square okhttp   chrominu cronet   微信 mars    

网络监控(一次往返的时间，从发起请求到收到响应，其实在volley已经做过了)
性能监控，aspect(编译插桩,最好的实现方案 360 APM未实践ArgusAPM #####未实践#####)

网络日志与远程诊断(#####未实践#####)


8 UI 优化

适配(dp, 限定符资源)
匿名共享内存(#####未实践#####)
overDraw  	



 高效开发
 程序员最痛恨写文档，还有别人不写文档
 9 编译: 三方开源的编译工具 facebook的Buck 与 google 的 bazel
 
 install run (增量编译)      
 
 10  编译插桩(AspectJ, ASM, ReDex)
 性能监控，网络监控，耗电监控
 
 java 文件的生成 (APT)
 
 字节码的修改(生成class字节码之后)

 
 监控三方SDK某个接口的性能(#####未实践#####)
 
 某个函数的性能有两种实现，一种是在调用端，一种是函数内部，两个问题： 调用点可能是有很多，第二 没有函数源码
 
插桩就是修改代码，例如，奔溃加try catch
无痕埋点: pageid, 控件 resource id(不会变有疑问)， 自动画埋点只能有简单数据，还需要自己设计一套DSL语言,能让插装代码通过反射获取到，这周验证（未验证）

DSL语言： test.a 表示实例test, 字段a  test.test()  表示实例test,调用test方法, [] 数组
插桩方法

java 文件 :  android annotation 自动生成java文件

字节码： 修改字节码(代码监控，代码修改，代码分析)  

操作字节码实现编译插桩功能：
  
AspectJ: 可以作用在方法被调用的位置，方法体，静态代码快，异常处理前后插入自定义的代码

简书大牛
https://www.jianshu.com/u/35083fcb7747

高可用上报组件：

数据往哪里写:  内存， mmap,  file 这三种方式需要做对比，对比两个维度， 根据数据量大小和写完时间的对比，在I/O优化中有 (未实践)

采样，存储，上报，容灾

代码埋点:xxx
可视化埋点  Mixpanel
无痕埋点: GrowingIO
   
鹏飞的学习心得   
c/c++ 环境编程参考文档   
https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5

焦虑不是迷茫与恐慌，而是认识到自己的不足，然后加足马力补齐短板

源码实现自己看，除非遇到某一个知识点跳不过去，采取搜答案，然后再验证

三方library，自己模拟实现
全栈发展：


framework 的学习方法
framework 主要内容: 
   代码              源码目录                   编译目录
系统相关widget       view                       framework.jar
系统AMS/PMS...       ../base/services           services.jar
系统内置资源         base/core                   framwork_res.apk

framework: 在没有刷机编译源码的情况下，使用android虚拟机与之对应的版本的系统代码调试, 最重要的是系统的class跑在哪个进程
           测试还是使用 android6.0 23模拟器吧

语言是(java与c++)
应用(四大组件启动流程)启动  (在没有刷机情况下，debug 没有成功)  
显示，
广播消息，
按键信息传递，
添加服务

anr 

service 启动过程， 
这里涉及到两个进程, 本进程与 system_service, AMS 告诉 service什么时候创建，至于真正创建(反射)在本进程，具体在ActivityThread.java里面

android_util_Binder.cpp  c++调用 ---> java(层的入口) Binder.execTransact(), 实例Binder对象的时候，调用native方法  init(),在c++层
保存了binder对象
不管是调用进程还是system_server进程， 在java层都是 Binder.execTransact() 都是这个入口，由c++调用

 
frmawork 在没有整个系统下的源码调试(主要是services.jar 和  framework.jar)

第一，虚拟机(不要选择google play,不能调试系统进程,选择对应的google api)与与sdk下的源码一致，当然这不一定，你可以自己按照包名copy
第二，确保代码与要调试的进程是一致的
验证方法： 以AMS系统服务为例子
1 查看system_server 的 pid
  ps -A |grep system_server
  ps |grep system_server
  
  
2 通过cat查看此进程的内存映射，是否有services 映射到内存里面
  cat /proc/{pid}/maps |grep services
  结果
  9ea30000-9f5fb000 r--p 00000000 fd:00 977        /system/framework/oat/x86/services.odex
  
  查看某个进程下
ps -T {pid} 
这里{pid}是使用ps -A |grep SystemServer查出 SystemServer的进程号

zygote 进程: 加载了framework.jar

generic_x86:/ # cat /proc/1428/maps |grep framework.jar
b6dcb000-b6dcc000 r--s 00000000 fd:00 945        /system/framework/framework.jar

其他进程都是zygote.fork()他的，所以其父进程加载的资源，都能被子进程找到


    
简历
面试
算法:

我们不应该焦虑，也不需要浮躁，没有不过是的技术，不过时的只有只有学习能力与态度

frameworks/base/services/core/java/com/android/server/am/ActiveServices.java

ActivityThread.main(){
 Looper.prepareMainLooper();
 xxxxxx

Looper.loop();
}
->准备好了一个looper{ MQ   }

sThreadLocal.set(new Looper(quitAllowed));
Looper 与 threadlocal(Thread.currentThread()获取) 关联



(frameworks/base/core/jni/android_os_MessageQueue.cpp)：
/system/core/libutils/include/utils/Looper.h

 obj.wait();  --> 调用到了 nativeWait();


uint64_t inc = 1;
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &inc, sizeof(uint64_t)));

int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);



ps -A |grep system_server

查看进程中的内存映射
cat /proc/xxxx/maps |grep services



android 源码调试: 使用工具Genymotion，启动模拟器，下载需要调试的java文件，建立同样的包名 (未实践)

init ---> zygote   zygote 进程生万物, 通过fork()子进程，内存copy快速集成父进程加载过的的资源，这里指定是 framework.jar, 所以你想替换
系统的class，没门, 注意support包不在framework.jar中哦，所以是可以替换的


thread 线程  (矛盾的两句话)
1 减少上下文切换的次数 --->  得出尽量少开线程
2 尽可能的提高CPU的使用率 ---> 

线程池开多少个线程，还有时间

客户端访问网络的任务特征 :

同一时间, 并发没有几个(超过10个网络任务已经算多了， 所以线程数量全开)，任务的执行时间都短，一般1~2秒就回来了

任务执行周期短

张绍文  --> 核心数的 0.7 背  4核 开3个
IO密集型 ，cpu密集型， 执行

synchronized  与 lock 的区别

synchronized 是 虚拟机的实现 ： monitor-enter p0    monitor-exit p0

lock 是java的实现


frameworks/base/services/core/java/com/android/server/am/
  - ActivityManagerService.java
  - ActiveServices.java
  - ServiceRecord.java
  - ProcessRecord.java

frameworks/base/core/java/android/app/
  - IActivityManager.java
  - ActivityManagerNative.java (内含AMP)
  - ActivityManager.java
  
  - IApplicationThread.java
  - ApplicationThreadNative.java (内含ATP)
  - ActivityThread.java (内含ApplicationThread)
  
  - ContextImpl.java
